//背包问题,有N件物品和一个容量为V的背包,第i件物品体积为c[i],价值为w[i],将哪些物品放入背包价值最大

//最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。设f[i][v]表示前i件物品放入容量为v的背包的最大价值,其状态转移方程为:
// f[i][v] = max{ f[i-1][v] , f[i-1][v-c[i]]+w[i] }  
//               (不放第i个)   (放第i个)

//将前i件物品放入容量为v的背包中这个子问题，若只考虑第i件物品的策略(放或不放)，那么就可以转化为一个只涉及前i-1件物品的问题。如果不放第i件物品，那么问题就转化为前i-1件物品放入容量为v的背包中，价值为f[i-1][v]；
//如果放第i件物品，那么问题就转化为前i-1件物品放入剩下的容量为v-c[i]的背包中，此时能获得的最大价值就是:  f[i-1][v-c[i]]+w[i]。

function get_price(N,V,c,w){
	var pick=new Array();//记录最大价值情况下,放入的物品编号
	
	var f=new Array(N+1);
	for(var i=0;i<=N;i++){
		f[i]=new Array(V+1);
		for(var j=0;j<=V;j++){
			f[i][j]=0;
		}
	}
	
	for(var i=1;i<=N;i++){//从第一个物品开始抉择放与不放,i=1表示只能放1号物品,f[1][j]存放背包容量为j时,可放置的最大价值,因为j=1时,c[1]=2>1,因此放不下1号,当j>=2时,最大价值都为1号物品的价值w[1],因此表格第一行储存 [0,6,6,6,6,6,6,6,6,6]	
	//同理i=2表示可以放1,2号物品,然后在背包容量增加的时候计算最大价值,按照公式得表格第二行储存 [0,6,6,9,9,9,9,9,9,9]
		for(var j=1;j<=V;j++){
			if((j-c[i])<0){
				var a=0;
			}else{
				var a=f[i-1][j-c[i]]+w[i];
			}
			f[i][j]=Math.max(f[i-1][j],a);
		}
	}
	return f;
}

function get_way(f,n,v,c,w,p){//求最大价值下,物品的选择方法 参数为表格f, 路径顶点坐标n,v, 重量数组c, 价值数组w, 物品选择的记录储存数组p
	if(n>0&&v>0){
		if(f[n-1][v]>f[n-1][v-c[n]]+w[n]){
			get_way(f,n-1,v,c,w,p);
		}else{
			p.push(n);
			get_way(f,n-1,v-c[n],c,w,p);
		}
	}else{
		return 0;
	}
	p.reverse();
	return p;//返回物品的挑选记录p
}



