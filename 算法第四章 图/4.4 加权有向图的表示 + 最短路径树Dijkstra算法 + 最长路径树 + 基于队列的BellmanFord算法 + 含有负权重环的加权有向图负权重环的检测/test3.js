//本文件的最小生成路径以选定的顶点s为起点
function sortUp(){
	var graph=[[4,5,0.35],[5,4,0.35],[4,7,0.37],[5,7,0.28],[7,5,0.28],[5,1,0.32],[0,4,0.38],[0,2,0.26],[7,3,0.39],[1,3,0.29],[2,7,0.34],[6,2,0.40],[3,6,0.52],[6,0,0.58],[6,4,0.93]];//普通加权有向图例
	
	// var graph=[[5,4,0.35],[4,7,0.37],[5,7,0.28],[5,1,0.32],[4,0,0.38],[0,2,0.26],[3,7,0.39],[1,3,0.29],[7,2,0.34],[6,2,0.4],[3,6,0.52],[6,0,0.58],[6,4,0.93]];//无环加权有向图例
	
	// var graph=[[4,5,0.35],[5,4,0.35],[4,7,0.37],[5,7,0.28],[7,5,0.28],[5,1,0.32],[0,4,0.38],[0,2,0.26],[7,3,0.39],[1,3,0.29],[2,7,0.34],[6,2,-1.2],[3,6,0.52],[6,0,-1.4],[6,4,-1.25]];//一般加权有向图例(含环,含负权重边)
	
	// var graph=[[4,5,0.35],[5,4,-0.66],[4,7,0.37],[5,7,0.28],[7,5,0.28],[5,1,0.32],[0,4,0.38],[0,2,0.26],[7,3,0.39],[1,3,0.29],[2,7,0.34],[6,2,0.4],[3,6,0.52],[6,0,0.58],[6,4,0.93]];//一般加权有向图例(含环,含负权重环)
	
	var k=new EdgeWeightedDigraph();//加权有向图类
	k.Insert(graph);
	k.Show();
	
	var sp=new DijkstraSP();//普通加权有向图最短路径的Dijkstra算法
	sp.DijkstraSP(k,0);
	sp.showPathTo(6);
	
	// var ac_sp=new AcyclicSp();//无环加权有向图最短路径的算法
	// ac_sp.AcyclicSp(k,5);//经过拓扑排序分析,以5为起点
	// ac_sp.showPathTo(2);//从起点s到任意顶点v的最短路径
	
	// var ac_lp=new AcyclicLp();//无环加权有向图最长路径的算法
	// ac_lp.AcyclicLp(k,5);//经过拓扑排序分析,以5为起点
	// ac_lp.showPathTo(2);//从起点s到任意顶点v的最长路径
	
	// var bell=new BellmanFordSP();
	// bell.BellmanFordSP(k,0);
	// var cycle=bell.negativeCycle();//找出负权重环
	// var edges=bell.edgeTo;
}
